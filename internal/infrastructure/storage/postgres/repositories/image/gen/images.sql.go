// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: images.sql

package gen

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createImage = `-- name: CreateImage :one
INSERT INTO images (
    id, original_name, file_name, status, result_url, size, format, uploaded_at
) VALUES (
             $1, $2, $3, $4, $5, $6, $7, $8
         )
    RETURNING id, original_name, file_name, status, result_url, size, format, uploaded_at
`

type CreateImageParams struct {
	ID           uuid.UUID      `json:"id"`
	OriginalName string         `json:"original_name"`
	FileName     string         `json:"file_name"`
	Status       string         `json:"status"`
	ResultUrl    sql.NullString `json:"result_url"`
	Size         int64          `json:"size"`
	Format       string         `json:"format"`
	UploadedAt   time.Time      `json:"uploaded_at"`
}

func (q *Queries) CreateImage(ctx context.Context, db DBTX, arg CreateImageParams) (Image, error) {
	row := db.QueryRowContext(ctx, createImage,
		arg.ID,
		arg.OriginalName,
		arg.FileName,
		arg.Status,
		arg.ResultUrl,
		arg.Size,
		arg.Format,
		arg.UploadedAt,
	)
	var i Image
	err := row.Scan(
		&i.ID,
		&i.OriginalName,
		&i.FileName,
		&i.Status,
		&i.ResultUrl,
		&i.Size,
		&i.Format,
		&i.UploadedAt,
	)
	return i, err
}

const createProcessedImage = `-- name: CreateProcessedImage :one
INSERT INTO processed_images (
    image_id, width, height, processed_at
) VALUES (
             $1, $2, $3, $4
         )
    RETURNING image_id, width, height, processed_at
`

type CreateProcessedImageParams struct {
	ImageID     uuid.UUID `json:"image_id"`
	Width       int32     `json:"width"`
	Height      int32     `json:"height"`
	ProcessedAt time.Time `json:"processed_at"`
}

func (q *Queries) CreateProcessedImage(ctx context.Context, db DBTX, arg CreateProcessedImageParams) (ProcessedImage, error) {
	row := db.QueryRowContext(ctx, createProcessedImage,
		arg.ImageID,
		arg.Width,
		arg.Height,
		arg.ProcessedAt,
	)
	var i ProcessedImage
	err := row.Scan(
		&i.ImageID,
		&i.Width,
		&i.Height,
		&i.ProcessedAt,
	)
	return i, err
}

const deleteImage = `-- name: DeleteImage :exec
DELETE FROM images
WHERE id = $1
`

func (q *Queries) DeleteImage(ctx context.Context, db DBTX, id uuid.UUID) error {
	_, err := db.ExecContext(ctx, deleteImage, id)
	return err
}

const deleteProcessedImage = `-- name: DeleteProcessedImage :exec
DELETE FROM processed_images
WHERE image_id = $1
`

func (q *Queries) DeleteProcessedImage(ctx context.Context, db DBTX, imageID uuid.UUID) error {
	_, err := db.ExecContext(ctx, deleteProcessedImage, imageID)
	return err
}

const getImageByID = `-- name: GetImageByID :one
SELECT id, original_name, file_name, status, result_url, size, format, uploaded_at FROM images
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetImageByID(ctx context.Context, db DBTX, id uuid.UUID) (Image, error) {
	row := db.QueryRowContext(ctx, getImageByID, id)
	var i Image
	err := row.Scan(
		&i.ID,
		&i.OriginalName,
		&i.FileName,
		&i.Status,
		&i.ResultUrl,
		&i.Size,
		&i.Format,
		&i.UploadedAt,
	)
	return i, err
}

const getImageWithProcessedData = `-- name: GetImageWithProcessedData :one
SELECT
    i.id, i.original_name, i.file_name, i.status, i.result_url, i.size, i.format, i.uploaded_at,
    p.width,
    p.height,
    p.processed_at
FROM images i
         LEFT JOIN processed_images p ON i.id = p.image_id
WHERE i.id = $1
`

type GetImageWithProcessedDataRow struct {
	ID           uuid.UUID      `json:"id"`
	OriginalName string         `json:"original_name"`
	FileName     string         `json:"file_name"`
	Status       string         `json:"status"`
	ResultUrl    sql.NullString `json:"result_url"`
	Size         int64          `json:"size"`
	Format       string         `json:"format"`
	UploadedAt   time.Time      `json:"uploaded_at"`
	Width        sql.NullInt32  `json:"width"`
	Height       sql.NullInt32  `json:"height"`
	ProcessedAt  sql.NullTime   `json:"processed_at"`
}

func (q *Queries) GetImageWithProcessedData(ctx context.Context, db DBTX, id uuid.UUID) (GetImageWithProcessedDataRow, error) {
	row := db.QueryRowContext(ctx, getImageWithProcessedData, id)
	var i GetImageWithProcessedDataRow
	err := row.Scan(
		&i.ID,
		&i.OriginalName,
		&i.FileName,
		&i.Status,
		&i.ResultUrl,
		&i.Size,
		&i.Format,
		&i.UploadedAt,
		&i.Width,
		&i.Height,
		&i.ProcessedAt,
	)
	return i, err
}

const getImagesByFileName = `-- name: GetImagesByFileName :many
SELECT id, original_name, file_name, status, result_url, size, format, uploaded_at FROM images
WHERE file_name = $1
ORDER BY uploaded_at DESC
`

func (q *Queries) GetImagesByFileName(ctx context.Context, db DBTX, fileName string) ([]Image, error) {
	rows, err := db.QueryContext(ctx, getImagesByFileName, fileName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Image{}
	for rows.Next() {
		var i Image
		if err := rows.Scan(
			&i.ID,
			&i.OriginalName,
			&i.FileName,
			&i.Status,
			&i.ResultUrl,
			&i.Size,
			&i.Format,
			&i.UploadedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getImagesStats = `-- name: GetImagesStats :one
SELECT
    COUNT(*) as total_images,
    COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_count,
    COUNT(CASE WHEN status = 'processing' THEN 1 END) as processing_count,
    COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_count,
    COALESCE(SUM(size), 0) as total_size
FROM images
`

type GetImagesStatsRow struct {
	TotalImages     int64       `json:"total_images"`
	CompletedCount  int64       `json:"completed_count"`
	ProcessingCount int64       `json:"processing_count"`
	FailedCount     int64       `json:"failed_count"`
	TotalSize       interface{} `json:"total_size"`
}

func (q *Queries) GetImagesStats(ctx context.Context, db DBTX) (GetImagesStatsRow, error) {
	row := db.QueryRowContext(ctx, getImagesStats)
	var i GetImagesStatsRow
	err := row.Scan(
		&i.TotalImages,
		&i.CompletedCount,
		&i.ProcessingCount,
		&i.FailedCount,
		&i.TotalSize,
	)
	return i, err
}

const getProcessedImage = `-- name: GetProcessedImage :one
SELECT image_id, width, height, processed_at FROM processed_images
WHERE image_id = $1 LIMIT 1
`

func (q *Queries) GetProcessedImage(ctx context.Context, db DBTX, imageID uuid.UUID) (ProcessedImage, error) {
	row := db.QueryRowContext(ctx, getProcessedImage, imageID)
	var i ProcessedImage
	err := row.Scan(
		&i.ImageID,
		&i.Width,
		&i.Height,
		&i.ProcessedAt,
	)
	return i, err
}

const getRecentProcessedImages = `-- name: GetRecentProcessedImages :many
SELECT
    i.id, i.original_name, i.file_name, i.status, i.result_url, i.size, i.format, i.uploaded_at,
    p.width,
    p.height,
    p.processed_at
FROM images i
         JOIN processed_images p ON i.id = p.image_id
WHERE p.processed_at >= $1
ORDER BY p.processed_at DESC
    LIMIT $2
`

type GetRecentProcessedImagesParams struct {
	ProcessedAt time.Time `json:"processed_at"`
	Limit       int32     `json:"limit"`
}

type GetRecentProcessedImagesRow struct {
	ID           uuid.UUID      `json:"id"`
	OriginalName string         `json:"original_name"`
	FileName     string         `json:"file_name"`
	Status       string         `json:"status"`
	ResultUrl    sql.NullString `json:"result_url"`
	Size         int64          `json:"size"`
	Format       string         `json:"format"`
	UploadedAt   time.Time      `json:"uploaded_at"`
	Width        int32          `json:"width"`
	Height       int32          `json:"height"`
	ProcessedAt  time.Time      `json:"processed_at"`
}

func (q *Queries) GetRecentProcessedImages(ctx context.Context, db DBTX, arg GetRecentProcessedImagesParams) ([]GetRecentProcessedImagesRow, error) {
	rows, err := db.QueryContext(ctx, getRecentProcessedImages, arg.ProcessedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentProcessedImagesRow{}
	for rows.Next() {
		var i GetRecentProcessedImagesRow
		if err := rows.Scan(
			&i.ID,
			&i.OriginalName,
			&i.FileName,
			&i.Status,
			&i.ResultUrl,
			&i.Size,
			&i.Format,
			&i.UploadedAt,
			&i.Width,
			&i.Height,
			&i.ProcessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listImages = `-- name: ListImages :many
SELECT id, original_name, file_name, status, result_url, size, format, uploaded_at FROM images
ORDER BY uploaded_at DESC
    LIMIT $1 OFFSET $2
`

type ListImagesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListImages(ctx context.Context, db DBTX, arg ListImagesParams) ([]Image, error) {
	rows, err := db.QueryContext(ctx, listImages, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Image{}
	for rows.Next() {
		var i Image
		if err := rows.Scan(
			&i.ID,
			&i.OriginalName,
			&i.FileName,
			&i.Status,
			&i.ResultUrl,
			&i.Size,
			&i.Format,
			&i.UploadedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listImagesByStatus = `-- name: ListImagesByStatus :many
SELECT id, original_name, file_name, status, result_url, size, format, uploaded_at FROM images
WHERE status = $1
ORDER BY uploaded_at DESC
    LIMIT $2 OFFSET $3
`

type ListImagesByStatusParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListImagesByStatus(ctx context.Context, db DBTX, arg ListImagesByStatusParams) ([]Image, error) {
	rows, err := db.QueryContext(ctx, listImagesByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Image{}
	for rows.Next() {
		var i Image
		if err := rows.Scan(
			&i.ID,
			&i.OriginalName,
			&i.FileName,
			&i.Status,
			&i.ResultUrl,
			&i.Size,
			&i.Format,
			&i.UploadedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listImagesWithFilters = `-- name: ListImagesWithFilters :many
SELECT id, original_name, file_name, status, result_url, size, format, uploaded_at FROM images
WHERE
    ($1::VARCHAR IS NULL OR status = $1) AND
    ($2::VARCHAR IS NULL OR format = $2) AND
    ($3::TIMESTAMP IS NULL OR uploaded_at >= $3) AND
    ($4::TIMESTAMP IS NULL OR uploaded_at <= $4)
ORDER BY uploaded_at DESC
    LIMIT $6 OFFSET $5
`

type ListImagesWithFiltersParams struct {
	Status   sql.NullString `json:"status"`
	Format   sql.NullString `json:"format"`
	FromDate sql.NullTime   `json:"from_date"`
	ToDate   sql.NullTime   `json:"to_date"`
	Offset   sql.NullInt32  `json:"offset"`
	Limit    sql.NullInt32  `json:"limit"`
}

func (q *Queries) ListImagesWithFilters(ctx context.Context, db DBTX, arg ListImagesWithFiltersParams) ([]Image, error) {
	rows, err := db.QueryContext(ctx, listImagesWithFilters,
		arg.Status,
		arg.Format,
		arg.FromDate,
		arg.ToDate,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Image{}
	for rows.Next() {
		var i Image
		if err := rows.Scan(
			&i.ID,
			&i.OriginalName,
			&i.FileName,
			&i.Status,
			&i.ResultUrl,
			&i.Size,
			&i.Format,
			&i.UploadedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateImage = `-- name: UpdateImage :one
UPDATE images
SET
    status = COALESCE($2, status),
    result_url = COALESCE($3, result_url)
WHERE id = $1
    RETURNING id, original_name, file_name, status, result_url, size, format, uploaded_at
`

type UpdateImageParams struct {
	ID        uuid.UUID      `json:"id"`
	Status    string         `json:"status"`
	ResultUrl sql.NullString `json:"result_url"`
}

func (q *Queries) UpdateImage(ctx context.Context, db DBTX, arg UpdateImageParams) (Image, error) {
	row := db.QueryRowContext(ctx, updateImage, arg.ID, arg.Status, arg.ResultUrl)
	var i Image
	err := row.Scan(
		&i.ID,
		&i.OriginalName,
		&i.FileName,
		&i.Status,
		&i.ResultUrl,
		&i.Size,
		&i.Format,
		&i.UploadedAt,
	)
	return i, err
}

const updateImageStatus = `-- name: UpdateImageStatus :one
UPDATE images
SET status = $2
WHERE id = $1
    RETURNING id, original_name, file_name, status, result_url, size, format, uploaded_at
`

type UpdateImageStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateImageStatus(ctx context.Context, db DBTX, arg UpdateImageStatusParams) (Image, error) {
	row := db.QueryRowContext(ctx, updateImageStatus, arg.ID, arg.Status)
	var i Image
	err := row.Scan(
		&i.ID,
		&i.OriginalName,
		&i.FileName,
		&i.Status,
		&i.ResultUrl,
		&i.Size,
		&i.Format,
		&i.UploadedAt,
	)
	return i, err
}

const updateProcessedImage = `-- name: UpdateProcessedImage :one
UPDATE processed_images
SET
    width = $2,
    height = $3,
    processed_at = $4
WHERE image_id = $1
    RETURNING image_id, width, height, processed_at
`

type UpdateProcessedImageParams struct {
	ImageID     uuid.UUID `json:"image_id"`
	Width       int32     `json:"width"`
	Height      int32     `json:"height"`
	ProcessedAt time.Time `json:"processed_at"`
}

func (q *Queries) UpdateProcessedImage(ctx context.Context, db DBTX, arg UpdateProcessedImageParams) (ProcessedImage, error) {
	row := db.QueryRowContext(ctx, updateProcessedImage,
		arg.ImageID,
		arg.Width,
		arg.Height,
		arg.ProcessedAt,
	)
	var i ProcessedImage
	err := row.Scan(
		&i.ImageID,
		&i.Width,
		&i.Height,
		&i.ProcessedAt,
	)
	return i, err
}
